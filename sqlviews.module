<?php

//  $loader = require_once __DIR__ . '/vendor/autoload.php';

// use Symfony\Component\Yaml

/**
 * @file
 * Proof of Concept for writing a gizmo for learning YAML.
 */

/**
 * Implements hook_menu().
 */
function sqlviews_menu() {
  $items['sqlviews'] = array(
    'title' => 'sqlVIEWS Test',
    'description' => 'Simple Test Page to Render the sqlVIEW.',
    'page callback' => 'sqlviews_page',
    'access callback' => TRUE,
  );
  $items['sqlviews/todo'] = array(
    'title' => 'sqlVIEWS To-Do',
    'description' => 'Simple To-Do List for the sqlVIEW module.',
    'page callback' => 'sqlviews_todo_page',
    'access callback' => TRUE,
    'type'=> MENU_CALLBACK,
  );
  $items['sqlviews/result'] = array(
    'title' => 'sqlVIEWS Result',
    'description' => 'Render Results for the sqlVIEW module.',
    'page callback' => 'sqlviews_result',
    'access callback' => TRUE,
    'type'=> MENU_CALLBACK,
  );
  return $items;
}

function sqlviews_page() {
	// drupal_set_message(__FUNCTION__);
  // $build = array(
  //   'header_text' => array(
  //     '#type' => 'markup',
  //     '#markup' => '<p>' . t("Simple Test Page to Render the sqlVIEW of Node Type '{$node_type}'.") . '</p><p>' . t(" That is, &mdash; displayed below &mdash; the SQL Code to render a result set of a stored query on the Node Type data, which the database users can see (and query) just as if it were a persistent database table. It is purposely composed to be as 'Human Readable' as is possibe.") . '</p>',
  //   ),
  // );
  // return $build;
	return drupal_get_form('sqlviews_form');
}

function sqlviews_form() {
  global $databases; 
  // dpm($databases);
  $database = $databases['default']['default']['database'];
  // dpm($database);
  $node_type_result = node_type_get_names();
  $disabled_type_overload_array = array('article', 'page');
  foreach ($node_type_result as $key => $value) {
    if (in_array($key, $disabled_type_overload_array)) {
      $node_type_result[$key] = $value . ' [disabled]';
    }
  }
  // dpm($node_type_result);
  $form_key = 'node_type_chex';
  $form[$form_key]['#required'] = true;
  $form[$form_key]['#type'] = 'radios';
  $form[$form_key]['#title'] = t('Select the Node-Types for which you would like to create a view');
  $form[$form_key]['#options'] = $node_type_result;
  $form[$form_key]['article']['#disabled'] = TRUE;
  $form[$form_key]['page']['#disabled'] = TRUE;

  $form_key = 'output_options';
  $form[$form_key]['#required'] = true;
  $form[$form_key]['#type'] = 'checkboxes';
  $form[$form_key]['#title'] = t('Select which Outputs you would like to execute');
  $form[$form_key]['#options'] = array(
    'code'=>'Render the SQL \'VIEW\' code', 
    'execute'=>'Execute the SQL \'VIEW\' code to Create (or Replace) the \'database VIEW\' for \'' . $database . '\'', 
    );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Execute',
    );
  return $form;
}

function sqlviews_form_submit($form, &$form_state) {
  drupal_set_message(t('The form has been submitted.'));
  dpm($form);
  dpm($form_state);
  dpm($_POST);
 
 if (is_string($form_state['values']['node_type_chex'])) {
 	$string = $form_state['values']['node_type_chex'];
 	$options['query'][$string] = $string;
 }elseif(is_array($form_state['values']['node_type_chex'])){
 	$string = 'array_unsupported';
 	$options['query'][$string] = $string;
 }

 if (is_string($form_state['values']['output_options'])) {
 	$string = $form_state['values']['output_options'];
 	$options['query'][$string] = $string;
 }elseif(is_array($form_state['values']['output_options'])){
 	$option_array = $form_state['values']['output_options'];
 	foreach ($option_array as $key => $value) {
 		if ($key === $value) {
 			$options['query'][$key] = $value;
 		}
 	}
 }

  // $options = array(
  //   // 'query' => array_merge($options_node_type, $options_output_options),
  //   'query' => array('node_type'=>'unbasic_page'),
  //   );
  dpm($options);
  $form_state['redirect'] = array('sqlviews/result', $options);
}

/**
 * Page demonstrating embedding a form on a page.
 * This should be MOOT at this juncture, but seems like a more extensible way to work
 */
function sqlviews_result() {
	global $databases;

	dpm($_GET);
 	$database = $databases['default']['default']['database'];
  // dpm($database);
	$node_type_result = node_type_get_names();
	$node_keys = array_keys($node_type_result);
	dpm($node_keys);
	$option_keys = array('code','execute');

	$node_type_array = array();
	$option_array = array();
	foreach ($_GET as $key => $value) {
		if (in_array($key, $node_keys)) {
			$node_type_array[] = $value;
		}
		if (in_array($key, $option_keys)) {
			$$key = $value;
		}
		$option_array = array();
	}
	$node_type = count($node_type_array) == 1?$node_type_array[0]:'ERROR: count='. count($node_type_array);
	$option_code = empty($code)?'NNULL':$code;
	$option_execute = empty($execute)?'NNULL':$execute;

	dpm($node_type);
	dpm($option_code);
	dpm($option_execute);

	// $node_type = 'many_fields';
	// $node_type = 'nonuser_contact';
	// $node_type = 'article';
	// $node_type = 'page';
	$node_type_sql = new nodeTypeSQL($node_type);
	// $node_type_sql = new nodeTypeSQL('nonuser_contact');
	// $node_type_sql = new nodeTypeSQL('article');

	// dpm($databases);
	// dpm($databases['default']['default']['database']);
	$node_type_sql->database = $databases['default']['default']['database'];
	// $node_type_sql->gatherFieldBundleSettings();
	// $node_type_sql->gatherWeightedFieldArray();
	// $node_type_sql->gatherObjectReadyFieldArray();
	// $node_type_sql->instantiateFieldObjects();
	// $node_type_sql->composeSelectStringFields_JoinStringFields();
	// $node_type_sql->composeJoinString();
	// $node_type_sql->composeSelectString();
	// $node_type_sql->composeQueryString();
	$node_type_sql->composeViewString();
	$node_type_sql_simple = array();
	$simple_attribute_array = array(
		'database',
		'type',
		'title_label',
		);
	foreach ($simple_attribute_array as $key) {
		$node_type_sql_simple[$key] = $node_type_sql->$key;
	}
	// dpm($node_type_sql_simple);
	// dpm($node_type_sql->view_string);
	$text_area = '<br><hr>
		<textarea name="message" rows="60" cols="90">
		' . $node_type_sql->view_string . '
		</textarea>	
		<br><hr><br>';
  $build = array(
    'header_text' => array(
      '#type' => 'markup',
      '#markup' => '<p>' . t("Simple Test Page to Render the sqlVIEW of Node Type '{$node_type}'.") . '</p><p>' . t(" That is, &mdash; displayed below &mdash; the SQL Code to render a result set of a stored query on the Node Type data, which the database users can see (and query) just as if it were a persistent database table. It is purposely composed to be as 'Human Readable' as is possibe.") . '</p>' . $text_area,
    ),
  );
  return $build;
}

/**
 * Page demonstrating embedding a form on a page.
 * This should be MOOT at this juncture, but seems like a more extensible way to work
 */
function sqlviews_todo_page() {
	$todo_array['brainstorm']['legend'] = 'Brain Strom';
	$todo_array['brainstorm']['item'][] = 'Include Article and Basic Page';
	$todo_array['brainstorm']['item'][] = 'Flesh-Out how to handle all kinds of Date fields &mdash; databse Date, ISO Date string, Integer';
	$todo_array['entity']['item'][] = 'Write \'Entity\' class with an array of EntityType objects';
	$todo_array['entity']['item'][] = 'Loop through each \'Entity Bundle\' for-each \'Entity\' with an array of Bundle objects';
	$todo_array['entity']['item'][] = '\_ indeed, current \'Node\'-centric module is like full-blown, where the only \'Bundles\' are Node \'Content-Types\.';

	$buffer = '';
	$fieldset_class = ' class="collapsible"';
	// $fieldset_class = ' class="collapsible collapsed"';
	foreach ($todo_array as $kind => $data_array) {
		$buffer .= "<fieldset{$fieldset_class}><legend>".$data_array['legend'].'</legend>';
		$buffer .= '<p><ul>';
		foreach ($data_array['item'] as $index => $string) {
			$buffer .= '<li>' . t($string) . '</li>';
		}
		$buffer .= '</ul></p>';
		$buffer .= '</fieldset>';
	}

	$build = array(
		'header_text' => array(
		  '#type' => 'markup',
		  '#markup' => '<p>' . t("Simple To-Do List for the sqlVIEW module:") . '</p><p>' . $buffer. '</p>',
		),
	);
	return $build;
}

